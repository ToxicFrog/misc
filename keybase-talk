#!/usr/bin/env zsh
# simple interactive chat UI for keybase chat
# usage: keybase-talk <conversation name> [channel name]

# keybase chat output format:
#     [index] [username timestamp] [expires in timestamp] reactji message
# - reactji are optional, and have the format: emoji [count]
#   or: :emoji-name: [count]
#   n.b. the space between the emoji and the count is optional!
#   similarly, there is no fixed number of spaces between the expiration counter
#   and the reactji, or the reactji and the message, beyond "at least one".
# - keybase hard-wraps messages, even if !isatty(stdout); lines after the first
#   will be prefixed with spaces to align them with the previous line.
#   these can be identified as a line starting with lots of spaces and no [index].
# - the "expires in" message is optional
# - for system messages, the message text itself is wrapped in [], e.g.
#     [3] [xxxxxxx 45s]                       [Added @yyyy to the team]

# Planned but not yet implemented features:
# /list,/join,/upload,/download
# /buf to switch which channel you're chatting in
# /msg to create a privmsg, may be eqv to /join in keybase
# /log <date range>
# /restart <args>
# Show activity in other chats in the status bar

# event handling
# change in user list: refresh user list
# event in current channel: refresh channel view
# event in other channel: refresh status bar
# messages will have msg.channel.name set to the conversation name, which will
# be the team name for messages in a team channel or "foo,bar" for PMs (where
# foo and bar are the participants).
# for team channels, msg.channel.topic_name will be set to the channel name
# jq -r '.result.messages | map([.msg.content.type,.msg.channel.name,.msg.channel.topic_name] | join("\t")) | .[]'
# jq -r '[.msg.content.type,.msg.channel.name,.msg.channel.topic_name] | join("\t")'
# known message types:
# attachment
# delete
# edit
# none -- a previously expired or deleted message
# reaction
# system -- so far only seen addedtoteam messages; should probably just refresh
#           everything on system messages
# text
# unfurl -- like text but has onebox information associated
# all of these will have type and name set, and topic_name if they're part of a team chat
# in practice we can just do something like:
# get target
#  if focused:
#   on text, unfurl, attach, delete, edit, none, or reaction, refresh text
#   on system, refresh text and user list
#  if not focused:
#   on text, unfurl, attach, or edit, mark as major activity
#   on delete, none, reaction, or system, mark as minor activity

# architecture
# top left pane contains text scroll. listens to /run/user/$UID/keybase-talk-$$-text.
#   Input is arguments to `keybase chat read`.
# top right pane contains user list. listens to /run/user/$UID/keybase-talk-$$-users.
#   Input is arguments to `keybase chat list-members`.
# bottom pane contains input and all control code.
# - keybase event listener runs in a zpty
# - event handler is attached to it with `zle -F`
#   - reads events, writes to /run/... or calls `zle reset-prompt` as needed
# - input is handled with `vared -p`
# - status line is actually the vared prompt, generated by a function
# - for performance reasons prompt is stored in a variable and only updated
#   by the event handler

# keybase chat is annoyingly inconsistent:
#  keybase chat read <conv> [--channel=foo]
#  keybase chat send <conv> [--channel=foo]
#  keybase chat list-members <conv> <channel>
# note that the former accepts both #foo and foo, and the latter only accepts foo

unsetopt function_argzero
setopt prompt_subst prompt_percent
function err { >&2 echo "$@"; }

#### Safety checks ####

missing=""
for prog in tmux od sed lua fold clear jq keybase; do
  if ! &>/dev/null type $prog; then
    missing="$missing $prog"
  fi
done
if [[ $missing ]]; then
  err "This script requires the following tools, but can't find them:$missing"
  exit 1
fi

if [[ ! $TMUX ]]; then
  err "This program must be run inside tmux."
  exit 2
fi

#### Entry point for top-level program ####
# n.b. entry points for the name list and chat window are further down, look
# for "function main/".

function main {
  # One more safety. We run this inside main because it doesn't apply to the
  # other entry points -- they expect to run after main has already created the
  # extra tmux panes.
  if (( $(tmux list-panes | wc -l) > 1 )); then
    err "I found more than one open tmux pane."
    err "This means either you have multiple panes open and I was about to ruin them, or that my pane-opening logic has a bug and I was about to crash your tmux server by creating infinitely many panes."
    exit 3
  fi

  # Strip leading hash from $2, if present.
  if [[ $2 ]]; then
    set -- $1 ${2#\#}
  fi

  setup-gui "$@"
  setup-input "$@"

  export LPROMPT="    $1${2/#%?*/#$2} ($(keybase chat list-members $@ | wc -l))"
  export RPROMPT="" # TODO show activity in other channels here

  while header "$@"; input=""; vared -h -p '$(left-prompt)' -r '$(right-prompt)' input; do
    case "$input" in
      /quit) break ;;
      /restart)
        shutdown
        exec "$0" "$@"
        ;;
      /sh) zoom $SHELL -i ;;
      /log) zoom /log "$@" ;;
      /help) zoom /help ;;
      /resize) /resize ;;
      /*)
        ;;
      # /join*)
      #   need to parse out args and then restart
      # /names|/who)
      #   requires `keybase list-members` to work, which it doesn't
      # /list)
      #   resize-pane -Z
      #   keybase chat list | less  # also need to list channels
      #   resize-pane -Z
      #   ;;
      *)
        keybase chat send \
          --exploding-lifetime=168h0m0s \
          ${2/#%?*/--channel=$2} $1 "$input"
        ;;
    esac
  done

  shutdown
}

function shutdown {
  clear
  tmux kill-pane -a -t $TMUX_PANE
}

#### UI management code ####

# Create the chat and, if needed, user list windows. Also sets up the WINCH handler.
function setup-gui {
  # Set up the windows.
  # The watcher goes in the top pane.
  # We create it above us (-b) and don't give it focus (-d)
  tmux split-window -l $((LINES-4)) -d -b "MAIN=main/chat $0 $*; echo 'chat watcher exited unexpectedly'; read"
  if [[ $2 ]]; then
    # User has requested an organization channel. Those have user lists, so
    # add a name list to the right of the chat pane.
    tmux split-window -l 20 -d -h -t 0 "MAIN=main/names $0 $*; echo 'name list exited unexpectedly'; read"
  fi
  # The input reader goes in the bottom (currently focused) pane.

  # Automatically resize page when size changes.
  trap /resize WINCH
}

# Configures ZLE for chat input.
function setup-input {
  # Initialize a new in-memory history, which will be used for the input box.
  fc -p -a /dev/null

  # Bind pageup/down to scroll through history.
  [[ -f ~/.zkbd/$TERM-$VENDOR-$OSTYPE ]] && source ~/.zkbd/$TERM-$VENDOR-$OSTYPE
  zle -N scroll-up
  bindkey "${key[PageUp]:=^[[5~}" scroll-up
  zle -N scroll-down
  bindkey "${key[PageDown]:=^[[6~}" scroll-down
  zle -N exit-scroll
  bindkey "^[" exit-scroll

  # These aren't bound by default, and we can't inherit the bindkey settings from
  # our parent shell (which may not even be zsh), so make an attempt here.
  bindkey "${key[Home]:=^[[1~}" beginning-of-line
  bindkey "${key[End]:=^[[1~}" end-of-line
}

# Draw the red status bar, left-hand status, and > prompt.
# LPROMPT is set externally and contains the channel name and user count.
function left-prompt {
  printf '%b' \
    '%{\x1Bc\x1B[0;0H%}%B%F{white}%K{red}' \
    $LPROMPT '%E%b%f%k\n> '
}

# Draw the right-hand status, typically empty or a list of active channels.
function right-prompt {
  printf '%b' \
    '%B%F{white}%K{red}%{' $(echotc UP 1) '%}' \
    '%-' $(( ${#LPROMPT}+2 )) '>...>' \
    $RPROMPT \
    '%>>%{' $(echotc DO 1) '%}%b%f%k'
}

function zoom {
  trap '' WINCH
  tmux resize-pane -Z
  "$@"
  tmux resize-pane -Z
  trap /resize WINCH
}

function scroll-up {
  tmux copy-mode -t 0 -e
  tmux send -t 0 PgUp
}

function scroll-down {
  # Send only in copy mode, otherwise we get garbage
  if [[ $(tmux display-message -t 0 -p -F '#{pane_in_mode}') == 1 ]]; then
    tmux send -t 0 PgDn
  fi
}

function exit-scroll {
  # Send only in copy mode, otherwise we get garbage
  if [[ $(tmux display-message -t 0 -p -F '#{pane_in_mode}') == 1 ]]; then
    tmux send -t 0 Escape
  fi
}

#### Implementation of /commands ####

function /log {
  keybase chat read \
    --since 1d --at-most 0 --at-least 10240 \
    "$@" \
    | pretty-chat | less -R +G
}

function /help {
  (cat | less) <<EOF
  Type a message and press enter to send it. Use pageup/down to scroll the chat history.
  You can also enter the following commands:

    /quit       exit keybase-talk and return your terminal to normal
    /restart    restart keybase-talk with the same arguments
    /sh         open a full-screen shell
    /help       this screen
    /log        show the last day of chat
    /resize     resize the UI to fit window; this should happen automatically

  This help screen (and /log) uses less(1), so use arrows and pageup/down to scroll, / and ? to search forward and back, and q to quit.

EOF
}

function /resize {
  tmux resize-pane -y 3
  if (( $(tmux list-panes | wc -l) > 2 )); then
    tmux resize-pane -t 1 -x 20
  fi
  # TODO: tell the talk pane to redraw
}

#### Name list ####

function main/names {
  local old_screen=""
  while true; do
    keybase chat list-members $@ | sed -E '1,2 d' | while read name; do
      printf '%s\n' $(formatnick $name)
    done
    sleep 60
  done
}

function formatnick {
  printf '\x1B[%dm%s\x1B[0m' $(hashnick $1) $1
}

function hashnick {
  echo "$1" | od -td1 -An -w1024 -v | sed -E 's,^ +,print((,; s, *$,)%6+31),; s, +,+,g;' | lua
}

#### Chat window ####

function main/chat {
  printf 'Loading chat history, please wait...'
  render-chat "$@"
  # keybase chat api-listen --exploding 2>/dev/null | jq --unbuffered -r .msg.content.type | while read event; do
  keybase chat api-listen --exploding 2>/dev/null | while read -r event; do
    render-chat "$@"
  done
}

function render-chat {
  local screen="$(
    keybase chat read \
      --at-least=$((LINES*4)) --at-most=$((LINES*4)) "$@" \
      | pretty-chat
    flush
  )"
  printf '\x1Bc\x1B[0;0H\x07%s' "$screen"
}

function pretty-chat {
  nick=""; message=""; reactji="";
  while read -r line; do parse-line "$line"; done
}

function parse-line {
  if [[ $1 == '['* ]]; then
    flush
    nick=$(echo "$1" | cut -d'[' -f3 | cut -d' ' -f1)
    message=$(echo "$1" | sed -E 's,\[expires in [^]]+\],,' | cut -d']' -f3- | trim)
    # the second space here is \xA0, nonbreaking space, so that `fold` later on doesn't
    # split it up.
    reactji=$(echo "$message" | egrep -o '^([^ ]+ ?\[[0-9]+\] )+' | sed -E 's, , ,g')
    if [[ $reactji ]]; then
      message=$(echo "$message" | egrep -o '  .*' | trim)
    fi
  else
    message="$message $(echo "$1" | trim)"
  fi
}

# Trim leading whitespace. Leaves trailing whitespace alone -- we need it for
# line pasting.
function trim {
  sed -E 's,^ +,,; s, +$,,'
}

function flush {
  if [[ $message == *'chat read error'* ]]; then
    # Skip errors, usually this means the message has expired or predates us joining the channel.
  else
    nick="<$(formatnick $nick)>"
    if [[ $reactji ]]; then
      message="$(printf '%s \x1B[48;2;60;60;60m%s\x1B[0m' $message $reactji)"
    fi
    printf '%s\n' "$message" | fold -s -w $((COLUMNS-22)) | while read -r line; do
      # Field width for the name is calculated as [20 + 9 nonprinting control code characters]
      # for a display width of 20.
      printf '%29s %s\n' "$nick" "$line"
      nick=$(printf '\x1B[000000m') # nine characters of nonprinting padding
    done
  fi
  nick=""
  message=""
  reactji=""
}


#### And awaaaaaay we go! ####

# Under normal circumstances this will be unset and thus main() will be called.
# When the program is re-invoking itself to run as the chat window or name window,
# this will be set to one of the other entry points.
${MAIN:=main} "$@"
