#!/usr/bin/env zsh
# simple interactive chat UI for keybase chat
# usage: keybase-talk <conversation name> [channel name]

# keybase chat output format:
#     [index] [username timestamp] [expires in timestamp] reactji message
# - reactji are optional, and have the format: emoji [count]
#   or: :emoji-name: [count]
#   n.b. the space between the emoji and the count is optional!
#   similarly, there is no fixed number of spaces between the expiration counter
#   and the reactji, or the reactji and the message, beyond "at least one".
# - keybase hard-wraps messages, even if !isatty(stdout); lines after the first
#   will be prefixed with spaces to align them with the previous line.
#   these can be identified as a line starting with lots of spaces and no [index].
# - the "expires in" message is optional
# - for system messages, the message text itself is wrapped in [], e.g.
#     [3] [xxxxxxx 45s]                       [Added @yyyy to the team]

# Planned but not yet implemented features:
# /list,/join,/upload,/download
# /buf to switch which channel you're chatting in
# /msg to create a privmsg, may be eqv to /join in keybase
# /log <date range>
# /restart <args>
# Show activity in other chats in the status bar

# event handling
# change in user list: refresh user list
# event in current channel: refresh channel view
# event in other channel: refresh status bar
# messages will have msg.channel.name set to the conversation name, which will
# be the team name for messages in a team channel or "foo,bar" for PMs (where
# foo and bar are the participants).
# for team channels, msg.channel.topic_name will be set to the channel name
# jq -r '.result.messages | map([.msg.content.type,.msg.channel.name,.msg.channel.topic_name] | join("\t")) | .[]'
# jq -r '[.msg.content.type,.msg.channel.name,.msg.channel.topic_name] | join("\t")'
# known message types:
# attachment
# delete
# edit
# none -- a previously expired or deleted message
# reaction
# system -- so far only seen addedtoteam messages; should probably just refresh
#           everything on system messages
# text
# unfurl -- like text but has onebox information associated
# all of these will have type and name set, and topic_name if they're part of a team chat
# in practice we can just do something like:
# get target
#  if focused:
#   on text, unfurl, attach, delete, edit, none, or reaction, refresh text
#   on system, refresh text and user list
#  if not focused:
#   on text, unfurl, attach, or edit, mark as major activity
#   on delete, none, reaction, or system, mark as minor activity

# keybase chat is annoyingly inconsistent:
#  keybase chat read <conv> [--channel=foo]
#  keybase chat send <conv> [--channel=foo]
#  keybase chat list-members <conv> <channel>
# note that the former accepts both #foo and foo, and the latter only accepts foo

unsetopt FUNCTION_ARGZERO

if [[ ! $TMUX ]]; then
  echo "This program must be run inside tmux."
  exit 1
fi

function hashnick {
  echo "$1" | od -td1 -An -w1024 -v | sed -E 's,^ +,print((,; s, *$,)%6+31),; s, +,+,g;' | lua
}

function formatnick {
  printf '\x1B[%dm%s\x1B[0m' $(hashnick $1) $1
}

# Trim leading whitespace. Leaves trailing whitespace alone -- we need it for
# line pasting.
function trim {
  sed -E 's,^ +,,; s, +$,,'
}

function flush {
  if [[ $message == *'chat read error'* ]]; then
    # Skip errors, usually this means the message has expired or predates us joining the channel.
  else
    nick="<$(formatnick $nick)>"
    if [[ $reactji ]]; then
      message="$(printf '%s \x1B[48;2;60;60;60m%s\x1B[0m' $message $reactji)"
    fi
    printf '%s\n' "$message" | fold -s -w $((COLUMNS-22)) | while read -r line; do
      # Field width for the name is calculated as [20 + 9 nonprinting control code characters]
      # for a display width of 20.
      printf '%29s %s\n' "$nick" "$line"
      nick=$(printf '\x1B[000000m') # nine characters of nonprinting padding
    done
  fi
  nick=""
  message=""
  reactji=""
}

function parse-line {
  if [[ $1 == '['* ]]; then
    flush
    nick=$(echo "$1" | cut -d'[' -f3 | cut -d' ' -f1)
    message=$(echo "$1" | sed -E 's,\[expires in [^]]+\],,' | cut -d']' -f3- | trim)
    # the second space here is \xA0, nonbreaking space, so that `fold` later on doesn't
    # split it up.
    reactji=$(echo "$message" | egrep -o '^([^ ]+ ?\[[0-9]+\] )+' | sed -E 's, ,Â ,g')
    if [[ $reactji ]]; then
      message=$(echo "$message" | egrep -o '  .*' | trim)
    fi
  else
    message="$message $(echo "$1" | trim)"
  fi
}

function pretty-chat {
  nick=""; message=""; reactji="";
  while read -r line; do parse-line "$line"; done
}

function render-chat {
  local screen="$(
    keybase chat read \
      --at-least=$((LINES*4)) --at-most=$((LINES*4)) "$@" \
      | pretty-chat
    flush
  )"
  printf '\x1Bc\x1B[0;0H\x07%s' "$screen"
}

function watch-chat {
  printf 'Loading chat history, please wait...'
  render-chat "$@"
  # keybase chat api-listen --exploding 2>/dev/null | jq --unbuffered -r .msg.content.type | while read event; do
  keybase chat api-listen --exploding 2>/dev/null | while read -r event; do
    render-chat "$@"
  done
}

function watch-names {
  local old_screen=""
  while true; do
    keybase chat list-members $@ | sed -E '1,2 d' | while read name; do
      printf '%s\n' $(formatnick $name)
    done
    sleep 60
  done
}

function shutdown {
  clear
  tmux kill-pane -a -t $TMUX_PANE
}

function header {
  if [[ $2 ]]; then
    printf '\x1Bc\x1B[0;0H\x1B[1;37;41m    %s #%s\x1B[0K\x1B[0m\n' \
      $1 $2
  else
    printf '\x1Bc\x1B[0;0H\x1B[1;37;41m    %s\x1B[0K\x1B[0m\n' \
      $1
  fi
}

#### Implementation of /commands ####

function /log {
  keybase chat read \
    --since 1d --at-most 0 --at-least 10240 \
    "$@" \
    | pretty-chat | less -R +G
}

function /help {
  (cat | less) <<EOF
  Type a message and press enter to send it. Use pageup/down to scroll the chat history.
  You can also enter the following commands:

    /quit       exit keybase-talk and return your terminal to normal
    /restart    restart keybase-talk with the same arguments
    /sh         open a full-screen shell
    /help       this screen
    /log        show the last day of chat
    /resize     resize the UI to fit window; this should happen automatically

  This help screen (and /log) uses less(1), so use arrows and pageup/down to scroll, / and ? to search forward and back, and q to quit.

EOF
}

function /resize {
  tmux resize-pane -y 3
  if (( $(tmux list-panes | wc -l) > 2 )); then
    tmux resize-pane -t 1 -x 20
  fi
  # TODO: tell the talk pane to redraw
}

#### Misc UI helpers ####

function zoom {
  trap '' WINCH
  tmux resize-pane -Z
  "$@"
  tmux resize-pane -Z
  trap /resize WINCH
}

function scroll-up {
  tmux copy-mode -t 0 -e
  tmux send -t 0 PgUp
}

function scroll-down {
  # Send only in copy mode, otherwise we get garbage
  if [[ $(tmux display-message -t 0 -p -F '#{pane_in_mode}') == 1 ]]; then
    tmux send -t 0 PgDn
  fi
}

function exit-scroll {
  # Send only in copy mode, otherwise we get garbage
  if [[ $(tmux display-message -t 0 -p -F '#{pane_in_mode}') == 1 ]]; then
    tmux send -t 0 Escape
  fi
}

#### Startup code ####

if [[ $1 == --watch ]]; then
  shift
  watch-chat "$@"
  exit 0
fi

if [[ $1 == --names ]]; then
  shift
  watch-names "$@"
  exit 0
fi

if (( $(tmux list-panes | wc -l) > 1 )); then
  echo "I found more than one open tmux pane."
  echo "This means either you have multiple panes open and I was about to ruin them, or that my pane-opening logic has a bug and I was about to crash your tmux server by creating infinitely many panes."
  exit 1
fi

# Strip leading hash from $2, if present.
if [[ $2 ]]; then
  set -- $1 ${2#\#}
fi

conv="$1"
if [[ "$2" ]]; then
  chan="--channel=$2"
else
  chan=""
fi

# Set up the windows.
# The watcher goes in the top pane.
# We create it above us (-b) and don't give it focus (-d)
tmux split-window -l $((LINES-4)) -d -b "$0 --watch $channel $conv; echo 'chat watcher exited unexpectedly'; read"
if [[ $2 ]]; then
  # User has requested an organization channel. Those have user lists, so
  # add a name list to the right of the chat pane.
  tmux split-window -l 20 -d -h -t 0 "$0 --names $*; echo 'name list exited unexpectedly'; read"
fi
# The input reader goes in the bottom (currently focused) pane.

# Automatically resize page when size changes.
trap /resize WINCH

# Initialize a new in-memory history, which will be used for the input box.
fc -p -a /dev/null

# Bind pageup/down to scroll through history.
zle -N scroll-up
bindkey "^[[5~" scroll-up
zle -N scroll-down
bindkey "^[[6~" scroll-down
zle -N exit-scroll
bindkey "^[" exit-scroll

while header "$@"; input=""; vared -h -p '> ' input; do
  case "$input" in
    /quit) break ;;
    /restart)
      shutdown
      exec "$0" "$@"
      ;;
    /sh) zoom $SHELL -i ;;
    /log) zoom /log "$@" ;;
    /help) zoom /help ;;
    /resize) /resize ;;
    /*)
      ;;
    # /join*)
    #   need to parse out args and then restart
    # /names|/who)
    #   requires `keybase list-members` to work, which it doesn't
    # /list)
    #   resize-pane -Z
    #   keybase chat list | less  # also need to list channels
    #   resize-pane -Z
    #   ;;
    *)
      keybase chat send \
        --exploding-lifetime=168h0m0s \
        $channel $conv "$input"
      ;;
  esac
done

shutdown
