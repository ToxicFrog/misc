#!/usr/bin/env zsh
#
# share -- ipfs-based file sharing
#
# Can share individual files, directories, or ad hoc collections of files and/or
# directories (which will be automatically wrapped in a directory).
#
# See `share help` for usage information.

# Future work: support sharing by IPNS. (This is why share state is maintained
# in the IPFS keystore). Currently it's disabled because private IPFS swarms
# don't support IPNS.

set -e

# Override these settings in ~/.config/ipfs-share if desired.

# export IPFS_PATH=/path/to/ipfs/dir
export IPFS_PATH

# If running a public node, replacing this with the URL of a gateway closer
# to your node is recommended for performance reasons.
# If running a private node you MUST replace this with the URL of a gateway
# connected to your private swarm.
export IPFS_GATEWAY=https://gateway.ipfs.io

# If you are running a private swarm you must disable this.
export ENABLE_IPNS=1

if [[ -f ~/.config/ipfs-share ]]; then
  source ~/.config/ipfs-share
fi

function share/main {
  local cmd="$1"; shift
  case $cmd in
    add|ls|rm|gc|help) share/cmd-$cmd "$@" ;;
    *)
      share/die "Unknown command '$cmd'. Try '$0 help'." ;;
  esac
}

function share/cmd-help {
  printf '%s\n'\
    "$0 -- a simple file sharing interface on top of ipfs."\
    "Usage:"\
    "  $0 add <dir>"\
    "    Share a directory and everything in it."\
    "  $0 add <list of files/dirs>"\
    "    Create a shared directory containing the listed files/dirs."\
    "  $0 ls [pattern]"\
    "    List all shares. With <pattern>, list only matching shares and their contents."\
    "  $0 rm [pattern]"\
    "    Remove all shares matching <pattern>."\
    "  $0 gc"\
    "    Delete from IPFS data associated with shares that have been removed."
    # "  $0 refresh [pattern]"\
    # "    Refresh expired shares so they become accessible again."\
}

function share/die {
  >&2 printf '%s\n' "$@"
  exit 1
}

# Add a share.
# If a single directory is specified, shares that directory as is.
# If a single file or multiple arguments are specified, wraps them in a directory
# (using -w) and shares that.
function share/cmd-add {
  local name=$(share/paths-to-name "$@")
  printf 'Name: %s\n' $name
  local hash
  if [[ $# == 1 && -d "$1" ]]; then
    hash=$(ipfs add -r -Q --progress "$1")
    printf 'IPFS: %s/ipfs/%s\n' $IPFS_GATEWAY $hash
  else
    hash=$(ipfs add -r -Q --progress -w "$@")
    if [[ $# == 1 ]]; then
      printf 'IPFS: %s/ipfs/%s/%s\n' $IPFS_GATEWAY $hash "$(basename $1 | sed 's, ,%20,g')"
    else
      printf 'IPFS: %s/ipfs/%s\n' $IPFS_GATEWAY $hash
    fi
  fi

  # Generate key based on ipfs hash and share name.
  local keyname="$(echo $name | tr / '\\')"
  local key="$hash:$keyname"

  # If a key already exists for this path with a matching hash, nothing to do
  # except refresh IPNS and return.
  if ipfs key list | fgrep -qx "$key"; then
    # Key already exists with matching hash.
    # Refresh IPNS and return.
    # TODO: IPNS doesn't work at all with private nodes.
    if (( ENABLE_IPNS )); then
      printf 'IPNS: %s/ipns/%s' $IPFS_GATEWAY $(share/publish $key $hash)
    fi
    return 0
  fi

  local old_hash=$(share/name-to-hash "$name")
  if [[ $old_hash ]]; then
    # Key exists with different hash.
    # Unpin the old hash and delete the key.
    local old_key="$old_hash:$keyname"
    ipfs pin rm $old_hash || printf 'Warning -- failed to unpin old data.\n' >&2
    ipfs key rm $old_key
    # ipfs repo gc
  fi

  # Key does not exist (or we just deleted it).
  ipfs key gen --type=rsa --size=2048 "$key" >/dev/null
  if (( ENABLE_IPNS )); then
    printf 'IPNS: %s/ipns/%s' $IPFS_GATEWAY $(share/publish $key $hash)
  fi
}

function share/paths-to-name {
  if [[ $# == 1 ]]; then
    if [[ -d "$1" ]]; then
      printf "%s/" "$(realpath "$1")"
    else
      realpath "$1"
    fi
  else
    local hash=$(printf '%s\n' "$@" | xargs -d\\n realpath | sort | sha1sum | cut -c1-8)
    local prefix=$(printf '%s\n' "$@" | xargs -d\\n realpath | sort | head -n1)
    if [[ -f $prefix ]]; then
      prefix="$(dirname $prefix)"
    fi
    # This is kind of gross.
    # TODO: come up with a better naming scheme for ad hoc dirs.
    printf '%s/<%d items>@%s' "$prefix" "$#" "$hash"
  fi
}

function share/publish {
  ipfs name publish --resolve=false --key="$1" "$2" | egrep -o '[^/]+$'
}

# Given a share name, look up the existing hash for it in the IPNS keystore.
function share/name-to-hash {
  local keyname="${1//\//\\}"
  ipfs key list | fgrep ":$keyname" | while IFS=: read -r hash name; do
    if [[ $name == "$keyname" ]]; then
      printf '%s' $hash
      return 0
    fi
  done
  return 1
}

# List all shares by name.
# If no arguments specified, lists all shares with their hashes.
# If arguments specified, shows only shares matching those args (as `grep`) and
# lists their name, IPFS path, IPNS path, and contents.
function share/cmd-ls {
  if [[ $1 ]]; then
    ipfs key list -l | egrep -v ' self *$' | grep "$@" | share/cmd-ls/contents
  else
    ipfs key list | fgrep -xv self | sed -E $'s,:,\t,' | tr '\\' / # $'\x16'
  fi
}

# Read keys from stdin and list their names, IPFS/IPNS paths and contents.
function share/cmd-ls/contents {
  while IFS=' :' read -r ipns ipfs name; do
    printf '\n'
    printf 'Name: %s\n' "$(printf '%s' $name | tr '\\' /)"
    printf 'IPFS: %s/ipfs/%s\n' $IPFS_GATEWAY $ipfs
    if (( ENABLE_IPNS )); then
      printf 'IPNS: %s/ipns/%s\n' $IPFS_GATEWAY $ipns
    fi
    ipfs ls $ipfs | tr -s ' ' | cut -d' ' -f3- | sed -E 's,^,    ,'
  done
}

# share rm name-or-id
# Remove share matching the given name or ID.
# No globbing/regex support yet.
function share/cmd-rm {
  local key
  while [[ $1 ]]; do
    key="$1"
    if [[ $key == /* ]]; then
      key=$(share/name-to-hash $key || share/die "No share found with name $key")
    fi
    key="$(share/hash-to-key $key || share/die "No share found with hash $key")"
    ipfs pin rm "$(printf '%s' $key | cut -d: -f1)"
    ipfs key rm $key
    shift
  done
}

function share/hash-to-key {
  ipfs key list | egrep "^$1:"
}

function share/cmd-gc {
  ipfs repo gc
}

exec share/main "$@"
