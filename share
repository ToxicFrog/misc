#!/usr/bin/env zsh
#
# share -- hash-based file sharing
#
# Can share individual files, directories, or ad hoc collections of files and/or
# directories (which will be automatically wrapped in a directory).
#
# See `share help` for usage information.

set -e
setopt no_function_argzero

SHARE_LIST="$HOME/.config/shares"
SHARE_PATH=${SHARE_PATH:=/srv/www/share}
SHARE_URL="https://ancilla.ancilla.ca/share"
PROGNAME="$(basename $0)"

missing=""
for prog in xxd pv fgallery rsync exiftool; do
  if ! &>/dev/null type $prog; then
    missing="$missing $prog"
  fi
done
if [[ $missing ]]; then
  echo "This script requires the following tools, but can't find them:$missing" >&2
  exit 1
fi

function share/main {
  touch $SHARE_LIST
  local cmd="$1"; shift
  while [[ $1 ]]; do
    case $1 in
      -n) local SHARE_NAME="$2"; shift 2;;
      --) shift; break;;
      -*) share/die "Unknown option '$1'";;
      *) break;;
    esac
  done
  if (( ${+functions[share-$cmd]} )); then
    share-$cmd "$@"
  else
    share/die "Unknown command '$cmd'. Try '$PROGNAME help'."
  fi
}

## share help [command]
# List available commands, or display help for a specific command.
function share-help {
  printf '%s\n'\
    "$PROGNAME -- a simple hash-based file sharing program."\
    "Usage:"\
    "  $PROGNAME add [-n name] <dir>"\
    "    Share a directory and everything in it."\
    "  $PROGNAME add [-n name] <list of files/dirs>"\
    "    Create a shared directory containing the listed files/dirs."\
    "  $PROGNAME add-album [-n name] <list of files/dirs>"\
    "    As add, but creates an HTML/JS thumbnail album from the contents."\
    "  $PROGNAME add-zip <name> <list of files/dirs>"\
    "    Like add, but creates a zip file with the given name and shares that instead."\
    "  $PROGNAME ls [pattern]"\
    "    List all shares. With <pattern>, list only matching shares and their contents."\
    "  $PROGNAME rm <name> [<name>...]"\
    "    Remove the named shares."\
}

### Library functions ###

# Print arguments to stderr and then exit.
function share/die {
  >&2 printf '%s\n' "$@"
  exit 1
}

# Generate a hash from the arguments.
# Internally, it's sha256sum in base64 with url-hostile characters replaced.
# Hash is based on UID + share name, so different people sharing the same thing
# have different share hashes.
function share/hash {
  printf '%s%s' "$UID" "$@" | sha256sum | cut -d' ' -f1 | xxd -r -p | base64 | tr '+/' '-_'
}

# register NAME
function share/register {
  local hash=$(share/hash $1)
  egrep -q "^$hash" $SHARE_LIST || printf '%s\x1F%s\n' "$hash" "$1" >> $SHARE_LIST
}

# unregister NAME
function share/unregister {
  local hash=$(share/hash $1)
  sed -E -i "/^$hash/ d" $SHARE_LIST
}

# True if a share with the given name exists.
function share/exists {
  egrep -q "^$(share/hash $1)" $SHARE_LIST
}

function share/paths-to-name {
  if [[ $SHARE_NAME ]]; then
    printf '%s' "$SHARE_NAME"
    return
  fi
  if [[ $# == 1 ]]; then
    if [[ -d "$1" ]]; then
      # Single directory argument: realpath with / suffix
      printf "%s/" "$(realpath "$1")"
    else
      # Single file argument: realpath with no suffix
      realpath "$1"
    fi
  else
    # This is so gross I'm just forbidding it for now.
    share/die "If you're sharing multiple things you need to specify a name with -n"
    # Multiple file and/or directory arguments. This needs work.
    # At the moment, the name is the first (lexical) argument with the first eight
    # characters of the sha1sum of all the arguments appended.
    local hash=$(printf '%s\n' "$@" | xargs -d\\n realpath | sort | sha1sum | cut -c1-8)
    local prefix=$(printf '%s\n' "$@" | xargs -d\\n realpath | sort | head -n1)
    # This is kind of gross.
    # TODO: come up with a better naming scheme for ad hoc dirs.
    printf '%s/<%d items>@%s' "$prefix" "$#" "$hash"
  fi
}

### Command implementations ###

## share add <file>
## share add <directory>
## share add <multiple files and/or directories...>
# Add a share.
# If a single directory is specified, shares that directory as is.
# If a single file or multiple arguments are specified, wraps them in a directory
# and shares that.
function share-add {
  local name=$(share/paths-to-name "$@")
  local hash=$(share/hash $name)
  if [[ "$1" == "-n" ]]; then
    shift 2
  fi
  if [[ $# == 1 && -d "$1" ]]; then
    # Add single directory
    command rsync -a --delete --info=progress2 "$1/" "$SHARE_PATH/$hash/"
    printf 'Name: %s\n' $name
    printf ' URL: %s/%s/\n' "$SHARE_URL" "$hash"
  else
    # One file, or multiple files and/or directories.
    # As with rsync, a trailing slash on directory arguments means "merge into"
    # and a lack of trailing slash means "copy into".
    command rsync -a --delete --info=progress2 "$@" "$SHARE_PATH/$hash/"
    printf 'Name: %s\n' $name
    if [[ $# == 1 ]]; then
      # Added single file
      printf ' URL: %s/%s/%s\n' "$SHARE_URL" "$hash" "$(basename $1 | sed 's, ,%20,g')"
    else
      # Added multiple files or dirs
      printf ' URL: %s/%s/\n' "$SHARE_URL" "$hash"
    fi
  fi

  share/register $name
}

# Add a source image ($2) to a gallery input directory ($1)
# Image types supported by fgallery are symlinked in.
# GIFs have a PNG thumbnail extracted and inserted.
function share/add-source-image {
  case "$(echo $2 | tr A-Z a-z)" in
    *.jpg|*.jpeg|*.png|*.tif|*.tiff)
      ln -s -r -f -t "$1" "$2"
      ;;
    *.gif)
      local frames=$(identify $2 | wc -l)
      if (( frames > 1 )); then
        local name=$(basename $2 | sed -E 's,\.gif$,,i')
        local size=$(convert "$2[0]" -format "%wx%h" info:)
        convert "$2[0]" \
          \( $HOME/devel/misc/play-circle.svg \
              -resize "$size" -resize "50%" \
              -gravity Center -negate \
          \) \
          -compose difference -composite "$1/$name.jpeg"
      else
        convert "$2" "$1/$name.jpeg"
      fi
      # Output the name of the renamed/converted file so the caller can
      # replace it later.
      echo "$name.jpeg"
      ;;
    *.mp4)
      local name=$(basename $2 | sed -E 's,\.mp4$,,i')
      # extract thumbnail from frame 30
      ffmpeg -hide_banner -loglevel quiet -i "$2" -vf "select=gte(n\,30)" -vframes 1 "$1/$name.thumb.jpeg"
      local size=$(convert "$1/$name.thumb.jpeg" -format "%wx%h" info:)
      convert "$1/$name.thumb.jpeg" \
        \( $HOME/devel/misc/play-circle.svg \
            -resize "$size" -resize "50%" \
            -gravity Center -negate \
        \) \
        -compose difference -composite "$1/$name.jpeg"
      rm "$1/$name.thumb.jpeg"
      echo "$name.jpeg"
      ;;
    *)
      echo "Skipping: $2" >&2
      ;;
  esac
}

## share add-album <files-and-directories...>
# As share, but generates an HTML album from the contents using fgallery
# and then shares that.
# Makes the original images available for download, but strips EXIF metadata
# from them first.
# GIFs and MP4 video are added to the gallery as thumbnails with a (>) overlay
# such that clicking on it takes you to the original file.
function share-add-album {
  local name=$(share/paths-to-name "$@")
  local hash=$(share/hash $name)

  echo "Generating gallery files..."
  trap "rm -rf /tmp/$$ /tmp/$$.fgallery" EXIT
  mkdir /tmp/$$
  # TODO: this unconditionally overwrites duplicates. Option to merge instead?
  local -A replacements
  find "$@" -type f | while read file; do
    local replacement=$(share/add-source-image "/tmp/$$" "$file")
    if [[ $replacement ]]; then
      replacements[$file]="$replacement"
    fi
  done
  # TODO: optional -f for face detection?
  # TODO: "persistent" mode, that keeps the generated gallery around for
  # incremental updates and remembers what arguments it was invoked with.
  # Generate gallery
  fgallery -j 4 -i -d --max-full 1024x1024 /tmp/$$ /tmp/$$.fgallery
  # Replace "fake" originals with the real originals
  for original replacement in "${(@kv)replacements}"; do
    rm /tmp/$$.fgallery/files/$replacement
    install -m 644 $original /tmp/$$.fgallery/files/
    sed -Ei 's,"files/'$replacement'","files/'$(basename $original)'",' /tmp/$$.fgallery/data.json
  done
  # Remove EXIF data from original JPEG files
  exiftool -all= -overwrite_original /tmp/$$.fgallery/files/*
  command rsync -a --delete --info=progress2 "/tmp/$$.fgallery/" "$SHARE_PATH/$hash/"

  printf 'Name: %s\n' $name
  printf ' URL: %s/%s/\n' "$SHARE_URL" "$hash"

  share/register $name
}

function share-add-zip {
  local name=$1; shift
  local hash=$(share/hash $name)
  if [[ $name =~ / ]] || [[ $name != *.zip ]]; then
    share/die "The first argument to add-zip must be a .zip file name with no slashes."
  fi

  mkdir -p "$SHARE_PATH/$hash"
  zip -q -0 -r - "$@" | pv > "$SHARE_PATH/$hash/$name"
  local dirhash=$(ipfs files stat --hash /.shares/$zipname)
  printf 'Name: %s\n' $name
  printf ' URL: %s/%s/%s\n' "$SHARE_URL" "$hash" "${name// /%20}"
  share/register $name
}

# List all shares by name.
# If no arguments specified, lists all shares with their hashes.
# If arguments specified, shows only shares matching those args (as `grep`) and
# lists their name, IPFS path, IPNS path, and contents.
function share-ls {
  if [[ $1 ]]; then
    share/ls-detail "$@"
  else
    cat $SHARE_LIST | sed -E 's,\x1F, ,'
  fi
}

# Read keys from stdin and list their names, IPFS/IPNS paths and contents.
function share/ls-detail {
  grep "$@" $SHARE_LIST | while IFS=$'\x1F' read -r hash name; do
    local count=$(find $SHARE_PATH/$hash -type f | wc -l)
    local size=$(du -sh --apparent-size $SHARE_PATH/$hash | cut -f1)
    printf '\n'
    printf 'Name: %s\n' $name
    printf 'Size: %s (%d files)\n' $size $count
    if (( count == 1 )); then
      printf ' URL: %s/%s/%s\n' $SHARE_URL $hash $(ls -A $SHARE_PATH/$hash | sed -E 's, ,%20,g')
    else
      printf ' URL: %s/%s/\n' $SHARE_URL $hash
    fi
  done
}

# share rm name
# Remove share matching the given name.
# No globbing/regex or remove by hash yet.
function share-rm {
  while [[ $1 ]]; do
    if ! share/exists $1; then
      share/die "No share with name '$1'"
    fi
    local hash="$(share/hash $1)"
    echo "Removing $1 ($hash)"
    rm -rf "$SHARE_PATH/$hash"
    share/unregister "$1"
    shift
  done
}

### Entry point ###

exec share/main "$@"
