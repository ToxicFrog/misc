// version:3
// SHODAN control program for SPU nodes.
// It will:
// - automatically discover rootable and hackable systems
// - get root on rootable systems we don't already have root on
// - start SPUs on idle systems we have root on
// - select targets from hackable systems and command the SPUs to attack them

import {initlib,netwalk,tprintf,printf,tryPwn,deploy,getSourceVersion} from "lib.ns";
import * as rpc from "rpc.ns";

var ns;
var HEARTBEAT_CHANNEL = "shodan";
var SPU_NAME = "spu.ns";
var MIN_MONEY_FOR_HACK = 2000000;
var DEPTH = 5;

var log = printf;

// Map from hostname to scanHost structure.
var info = {};
// Map from target hostname to desired/pending jobs for that host.
// Also records target money level for the host before we'll try hack() again.
// job_queue is the sorted version of the same objects, highest priority first.
var jobs = {};
var job_queue = [];
// Map from worker hostname to { threads, command }
var workers = {};

var silence = [
  "sleep", "getServerRam", "getServerNumPortsRequired", "scan",
  "getServerSecurityLevel", "getServerMinSecurityLevel", "getServerMoneyAvailable",
  "getServerMaxMoney", "getServerRequiredHackingLevel", "getHackingLevel",
];
export async function main(n) {
  ns = n;
  initlib(ns);
  for (let fn of silence) ns.disableLog(fn);
  let MY_VERSION = getSourceVersion(ns.getScriptName());

  rpc.init(ns);
  rpc.create(HEARTBEAT_CHANNEL);

  await scanHosts(DEPTH, false);
  await expandSwarm();
  tprintf("SHODAN startup complete.");

  while (true) {
    await readAndProcessHeartbeat();
    await scanHosts(DEPTH, false);
    await expandSwarm();
    rpc.publishStatus(null, {tasks: job_queue, workers: workers});
    if (getSourceVersion(ns.getScriptName()) != MY_VERSION) {
      tprintf("New version found: %s -> %s. Restarting...",
        MY_VERSION, getSourceVersion(ns.getScriptName()));
      ns.spawn(ns.getScriptName(), 1);
    }
  }
}

//// HOST SCANNING AND JOB GENERATION ////

// Scan all reachable hosts out to maxdepth.
// Roots the ones that are rootable, and populates info{} and the "target" fields
// in jobs{}.
async function scanHosts(maxdepth, verbose) {
  async function checkHost(host, depth) {
    let stat = await scanHost(host);
    updateJobForHost(host);
    if (verbose) {
      tprintf("%-18s %3d %s %s %3d/%-3dGB %3d/%-3dSc H:%.3f * $%.0f",
        " ".repeat(depth) + host, stat.hack_level,
        stat.root ? "R" : " ", ns.scriptRunning(SPU_NAME, host) ? "SPU" : "   ",
        stat.ram_used, stat.ram,
        stat.security, stat.min_security,
        stat.hack_fraction,
        stat.money);
    }
    return (depth < maxdepth);
  }

  await netwalk(checkHost, "home");
}

// Scan a single host. Updates its info{} entry and returns the new entry.
async function scanHost(host) {
  let stat = {};
  stat.name = host;
  stat.root = await tryPwn(host);
  stat.ram = ns.getServerRam(host)[0];
  stat.ram_used = ns.getServerRam(host)[1];
  stat.security = ns.getServerSecurityLevel(host);
  stat.min_security = ns.getServerMinSecurityLevel(host);
  stat.money = ns.getServerMoneyAvailable(host);
  stat.max_money = ns.getServerMaxMoney(host);
  stat.hack_level = ns.getServerRequiredHackingLevel(host);
  stat.hack_fraction = ns.hackAnalyzePercent(host)/100;
  info[host] = stat;
  return stat;
}

// Generates a job table entry for the given host, or, if one already exists,
// updates it based on the contents of info{}. Writes the updated job table
// entry to jobs{} and returns it.
function updateJobForHost(host) {
  let stat = info[host];
  if (!stat.root || !stat.money || stat.hack_level > ns.getHackingLevel()) {
    jobs[host] = null;
    return;
  }
  let job = jobs[host];
  if (!job) {
    // Create new job table entry.
    job = {
      host: host,
      weaken: 0, grow: 0, hack: 0,
      pending_weaken: 0, pending_grow: 0, pending_hack: 0,
      target_money: Math.min(Math.max(stat.money, MIN_MONEY_FOR_HACK), stat.max_money)
    };
    jobs[host] = job;
    job_queue.push(job);
    tprintf("Target: %24s  ⌨%-3d  🔐%3d/%-3d  $%.3e",
      host, stat.hack_level, stat.security, stat.min_security, stat.money);
  }

  if (stat.security > stat.min_security + 2) {
    job.weaken = Math.ceil((stat.security - stat.min_security) * 20);
    job.grow = 0;
    job.hack = 0;
  } else if (stat.money < job.target_money) {
    job.weaken = 0;
    job.grow = ns.growthAnalyze(host, job.target_money/stat.money);
    job.hack = 0;
  } else {
    job.weaken = 0;
    job.grow = 0;
    job.hack = 1;
    job.target_money = stat.money;
  }

  return job;
}

function jobToString(job) {
  return sprintf("%16.16s w%3d/%-3d g%3d/%-3d h%3d/%-3d  %.3e $ %-.3e",
    job.host, job.pending_weaken, job.weaken,
    job.pending_grow, job.grow,
    job.pending_hack, job.hack,
    info[job.host].money, job.target_money);
}

//// SWARM EXPANSION ////

async function expandSwarm() {
  for (let host in info) {
    let stat = info[host];
    if (!stat.root || stat.ram_used > 0) continue;
    await installSPU(host);
    await scanHost(host);
  }
}

async function installSPU(host) {
  let version = getSourceVersion(SPU_NAME);
  let cost = ns.getScriptRam(SPU_NAME);
  let threads = Math.floor(info[host].ram/cost);
  if (threads < 1) return;
  tprintf("SPU: installing on %s.", host, version, threads);
  await deploy(host, SPU_NAME, version);
}

//// HEARTBEAT HANDLING ////

// Read and react to a single heartbeat.
// - Update the host information for the target of the worker's last order
// - Push a new SPU version to the worker if needed
// - Send the worker a new order
async function readAndProcessHeartbeat() {
  let hb = await rpc.recv(HEARTBEAT_CHANNEL, 60.0);
  if (!hb) return; // timeout
  log("Heartbeat from %s with %d threads running SPU %s",
    hb.host, hb.threads, hb.version);

  await processWorkResults(hb);
  let updated = await maybeUpdateSPU(hb.host, hb.version);
  if (updated) return; // It'll send a new heartbeat when it's done starting up.
  await assignWorkTo(workers[hb.host]);
}

async function processWorkResults(hb) {
  let host = hb.host;
  if (!workers[host] || !workers[host].job) {
    // No entry for this worker; it was previously unknown to us.
    // Create a new default entry for it.
    tprintf("SPU: %s running SPU %s with %d threads.", host, hb.version, hb.threads);
    workers[host] = hb;
    await scanHosts(DEPTH, false);
    return;
  }
  // We know what job this worker was doing. Update the job table to record
  // that it finished, then rescan its target and update the target job values.
  let command = workers[host].job[0];
  let target = workers[host].job[1];
  jobs[target]["pending_" + command] -= workers[host].threads;
  await scanHost(target);
  updateJobForHost(target);
  workers[host].job = null;
  log(" - %s (%s×%d)", jobToString(jobs[target]), command, workers[host].threads);
  // tprintf("  + %s", jobToString(jobs[target]));
}

async function maybeUpdateSPU(host, deployed_version) {
  let version = getSourceVersion(SPU_NAME);
  if (version == deployed_version) return false;
  tprintf("SPU: %s upgrade %s -> %s",
    host, deployed_version, version);
  await rpc.send("SPU@" + host, ["exit"]);
  workers[host] = null;
  while (ns.ps(host).length > 0) await ns.sleep(100);
  await deploy(host, SPU_NAME, version);
  return true;
}

async function assignWorkTo(worker) {
  sortJobQueue();
  for (let job of job_queue) {
    if (job.pending_weaken < job.weaken) {
      return await setJob(worker, job, "weaken");
    }
    if (job.pending_grow < job.grow) {
      return await setJob(worker, job, "grow");
    }
    if (job.pending_hack < job.hack) {
      return await setJob(worker, job, "hack");
    }
  }
  // If we get this far all jobs are populated, so we throw up our hands and
  // tell it to grow() whatever has the least target money.
  // We'll probably want to be smarter about this later.
  let job = job_queue.reduce(function (x,y) {
    return x.target_money < y.target_money ? x : y;
  });
  await setJob(worker, job, "grow");
}

// Attempts to estimate how quickly we can extract money from this system, based
// on (target_money * hack_fraction)/hack_time.
// Penalizes time if the system needs to be weakened or grown first.
function getMoneyPerTime(job) {
  let stat = info[job.host];
  return (job.target_money * stat.hack_fraction)
       / (ns.getHackTime(job.host) * (1 + job.weaken?1:0 + job.grow?1:0));
}

// We prioritize hack over everything, to get immediate cash flow.
// After hacks, we focus on whatever needs the most threads.
function sortJobQueue() {
  job_queue.sort(function (x,y) {
    return getMoneyPerTime(y) - getMoneyPerTime(x);
  });
}

async function setJob(worker, job, command) {
  job["pending_" + command] += worker.threads;
  worker.job = [command, job.host];
  await rpc.send("SPU@" + worker.host, [command, job.host]);
  log(" + %s (%s×%d)", jobToString(job), command, worker.threads);
}
