// version:20
// SHODAN control program for SPU nodes.
// It will:
// - automatically discover rootable and hackable systems
// - get root on rootable systems we don't already have root on
// - start SPUs on idle systems we have root on
// - select targets from hackable systems and command the SPUs to attack them
// TODO: automatically scan for .cct files and other interesting files on hacked
// machines, copy them back to home, and generate a notification.

import {initlib,netwalk,tprintf,printf,tryPwn,deploy,getSourceVersion,time,resetTimer} from "lib.ns";
import {tryUpgradeServer,canUpgradeServer,init_autobuy} from "autobuy.ns";
import * as rpc from "rpc.ns";

var ns;
var HEARTBEAT_CHANNEL = "shodan";
var SPU_NAME = "spu.ns";
var MIN_MONEY_FOR_HACK = 2000000;
// How far out to scan the network.
var DEPTH = 10;
// Don't hack more than this much money at a time.
var MAX_HACK_RATIO = 0.5;
// Grow server money by this much between hacks.
var GROWTH_FACTOR = 2.0;
// Don't spend more than this much money upgrading a dedicated server.
var SERVER_UPGRADE_FACTOR = 0.004;
// Time between full network rescans, seconds.
var TIME_BETWEEN_SCANS = 60*5;
// Maximum number of threads to run in a single SPU shard.
var MAX_THREADS_PER_SHARD = 16;

var log = printf;

// Map from hostname to scanHost structure.
let info;
// Map from target hostname to desired/pending jobs for that host.
// Also records target money level for the host before we'll try hack() again.
// job_queue is the sorted version of the same objects, highest priority first.
let jobs, job_queue;

let silence = [
  "sleep", "getServerRam", "getServerNumPortsRequired", "scan",
  "getServerSecurityLevel", "getServerMinSecurityLevel", "getServerMoneyAvailable",
  "getServerMaxMoney", "getServerRequiredHackingLevel", "getHackingLevel",
];
export async function main(n) {
  ns = n;
  initlib(ns);
  init_autobuy(ns);
  resetTimer();
  for (let fn of silence) ns.disableLog(fn);
  let MY_VERSION = getSourceVersion(ns.getScriptName());
  info = {}; jobs = {}; job_queue = [];

  rpc.init(ns);
  rpc.create(HEARTBEAT_CHANNEL);

  await scanHosts(DEPTH, false);
  await expandSwarm();
  tprintf("SHODAN startup complete.");

  while (true) {
    rpc.publishStatus(null, {tasks: job_queue});
    await readAndProcessHeartbeat();
    if (time() >= TIME_BETWEEN_SCANS) {
      await scanHosts(DEPTH, false);
      await expandSwarm();
      resetTimer();
    }
    if (getSourceVersion(ns.getScriptName()) != MY_VERSION) {
      tprintf("New version found: %s -> %s. Restarting...",
        MY_VERSION, getSourceVersion(ns.getScriptName()));
      ns.spawn(ns.getScriptName(), 1);
    }
  }
}

//// HOST SCANNING AND JOB GENERATION ////

// Scan all reachable hosts out to maxdepth.
// Roots the ones that are rootable, and populates info{} and the "target" fields
// in jobs{}.
async function scanHosts(maxdepth, verbose) {
  async function checkHost(host, depth) {
    let stat = await scanHost(host);
    updateJobForHost(host);
    if (verbose) {
      tprintf("%-18s %3d %s %s %3d/%-3dGB %3d/%-3dSc H:%.3f * $%.0f",
        " ".repeat(depth) + host, stat.hack_level,
        stat.root ? "R" : " ", ns.scriptRunning(SPU_NAME, host) ? "SPU" : "   ",
        stat.ram_used, stat.ram,
        stat.security, stat.min_security,
        stat.hack_fraction,
        stat.money);
    }
    return (depth < maxdepth);
  }

  log("Performing full network scan of depth %d", maxdepth);
  await netwalk(checkHost, "home");
}

// Scan a single host. Updates its info{} entry and returns the new entry.
async function scanHost(host) {
  let stat = {};
  stat.name = host;
  stat.root = await tryPwn(host);
  stat.ram = ns.getServerRam(host)[0];
  stat.ram_used = ns.getServerRam(host)[1];
  stat.security = ns.getServerSecurityLevel(host);
  stat.min_security = ns.getServerMinSecurityLevel(host);
  stat.money = ns.getServerMoneyAvailable(host);
  stat.max_money = ns.getServerMaxMoney(host);
  stat.hack_level = ns.getServerRequiredHackingLevel(host);
  stat.hack_fraction = ns.hackAnalyzePercent(host)/100;
  info[host] = stat;
  return stat;
}

// Generates a job table entry for the given host, or, if one already exists,
// updates it based on the contents of info{}. Writes the updated job table
// entry to jobs{} and returns it.
// If the host is no longer a valid target, deletes it from the job table.
function updateJobForHost(host) {
  let stat = info[host];
  if (!stat.root || !stat.max_money || stat.hack_level > ns.getHackingLevel()) {
    jobs[host] = null;
    job_queue = job_queue.filter(function (task) {
      return task.host != host;
    })
    return;
  }
  let job = jobs[host];
  if (!job) {
    // Create new job table entry.
    job = {
      host: host,
      weaken: 0, grow: 0, hack: 0,
      pending_weaken: 0, pending_grow: 0, pending_hack: 0,
      target_money: Math.min(Math.max(stat.money, MIN_MONEY_FOR_HACK), stat.max_money)
    };
    jobs[host] = job;
    job_queue.push(job);
    tprintf("Target: %24s  ⌨%-3d  🔐%3d/%-3d  $%.3e",
      host, stat.hack_level, stat.security, stat.min_security, stat.money);
  }

  job.weaken = Math.ceil((stat.security - stat.min_security) * 20);
  job.hack = (stat.money >= job.target_money) ? 1 : 0;
  job.grow = Math.max(0, ns.growthAnalyze(host, job.target_money/stat.money));

  return job;
}

function jobToString(job) {
  return sprintf("%16.16s w%3d/%-3d g%3d/%-3d h%3d/%-3d  %.3e $ %-.3e",
    job.host, job.pending_weaken, job.weaken,
    job.pending_grow, job.grow,
    job.pending_hack, job.hack,
    info[job.host].money, job.target_money);
}

//// SWARM EXPANSION ////

async function expandSwarm() {
  for (let host in info) {
    let stat = info[host];
    if (!stat.root || stat.ram_used > 0) continue;
    await installSPU(host);
    await scanHost(host);
  }
}

async function installSPU(host) {
  let version = getSourceVersion(SPU_NAME);
  let cost = ns.getScriptRam(SPU_NAME);
  let threads = Math.floor(info[host].ram/cost);
  if (threads < 1) return;
  if (threads <= MAX_THREADS_PER_SHARD)
    tprintf("SPU: installing %s on %s (%d threads).", version, host, threads);
  else
    tprintf("SPU: installing %s on %s (%d threads / %d shards).",
      version, host, threads, Math.ceil(threads/MAX_THREADS_PER_SHARD));
  await deploy(host, SPU_NAME, MAX_THREADS_PER_SHARD, version);
}

//// HEARTBEAT HANDLING ////

// Read and react to a single heartbeat.
// - Update the host information for the target of the worker's last order
// - Push a new SPU version to the worker if needed
// - Send the worker a new order
async function readAndProcessHeartbeat() {
  let hb = await rpc.recv(HEARTBEAT_CHANNEL, 60.0);
  if (!hb) return; // timeout
  // log("Heartbeat from %s with %d threads running SPU %s",
  //   hb.host, hb.threads, hb.version);

  await processWorkResults(hb);
  let upgraded = await maybeUpgradeServer(hb.host);
  if (upgraded) {
    log("%18s:  %s  ->  %s", hb.host, (hb.task || ["(idle)"]).join(" "), "UPGRADE");
    log("HACK HACK HACK: restarting after server upgrade");
    ns.spawn(ns.getScriptName(), 1);
    return;
  }
  let updated = await maybeUpdateSPU(hb.host, hb.version);
  if (updated) {
    log("%18s:  %s  ->  %s", hb.host, (hb.task || ["(idle)"]).join(" "), "UPDATE");
    return; // It'll send a new heartbeat when it's done starting up.
  }
  await assignWorkTo(hb);
}

async function processWorkResults(hb) {
  let host = hb.host;
  if (!hb.task) return; // SPU was previously idle, no need to collect results.

  // We know what job this worker was doing. Update the job table to record
  // that it finished, then rescan its target and update the target job values.
  let command = hb.task[0];
  let target = hb.task[1];
  await scanHost(target);
  if (!updateJobForHost(target)) {
    // This happens if we accidentally hacked 100% of the target's money.
    log("  Oops -- SPU %s's target, %s, was destroyed.", hb.host, hb.target);
    return;
  } else {
    // Reduce the "pending threads" count for the task it was working on.
    // Prevent it from going below 0, which happens if we just started up
    // and SPUs are reporting in that we didn't previously know about.
    jobs[target]["pending_" + command] = Math.max(
      0, jobs[target]["pending_" + command] - hb.threads);
    // If we just completed a hack against this target, bump the target_money
    // up so that the next hack is bigger.
    if (command == "hack")
      jobs[target].target_money = Math.min(info[target].max_money, jobs[target].target_money * GROWTH_FACTOR);
  }
  // log(" - %s (%s×%d)", jobToString(jobs[target]), command, hb.threads);
}

async function maybeUpgradeServer(spu_name) {
  let host = spu_name.split(":")[0];
  if (!host.match("^spu[0-9]+$")) return false;
  let budget = ns.getServerMoneyAvailable("home") * SERVER_UPGRADE_FACTOR;
  // if (canUpgradeServer(budget, host)) {
    // let nps = ns.ps(host).length
    // await rpc.send("SPU@" + spu_name, ["exit"]);
    // while (ns.ps(host).length == nps) await ns.sleep(100);
    // log("Shut down %s to prepare for hardware upgrade (%d shards left).",
    //   spu_name, ns.ps(host).length);
    // if (ns.ps(host).length == 0) {
    //   log("Upgrading %s", host);
     return await tryUpgradeServer(budget, host);
    // }
  //   return true;
  // }
  // return false;
}

// This is tricky because the SPU might be sharded, in which case "host" will
// actually be in the format "hostname:shard". I should have named it "spu_name"
// or something, oops.
async function maybeUpdateSPU(spu_name, deployed_version) {
  let version = getSourceVersion(SPU_NAME);
  if (version == deployed_version) return false;
  tprintf("SPU: %s upgrade %s -> %s",
    spu_name, deployed_version, version);

  let [host,shard] = spu_name.split(":");
  await rpc.send("SPU@" + spu_name, ["exit"]);
  while (ns.scriptRunning(host).length > 0) await ns.sleep(100);
  if (shard === undefined) {
    // unsharded deployment
    await deploy(host, SPU_NAME, MAX_THREADS_PER_SHARD, version);
  } else {
    // here's where it gets complicated -- we can't just call deploy() because it'll
    // try to re-shard the script from scratch.
    // For now we just leave it dead and let the whole server get upgraded once all the
    // SPUs on it have exited.
    printf("Warning: leaving SPU %s dead because we can't do per-shard upgrades yet.",
      spu_name);
  }
  return true;
}

async function assignWorkTo(worker) {
  sortJobQueue();
  for (let job of job_queue) {
    if (job.weaken) {
      if (job.pending_weaken < job.weaken)
        return await setJob(worker, job, "weaken");
      // If there are any pending weakens, don't run anything else against
      // this target.
      continue;
    }
    if (job.pending_hack < job.hack) {
      // Additional checks to make sure we don't nuke an entire server.
      if (info[job.host].hack_fraction * worker.threads > MAX_HACK_RATIO) continue;
      return await setJob(worker, job, "hack");
    }
    if (job.pending_grow < job.grow) {
      return await setJob(worker, job, "grow");
    }
  }
  // If we get this far all jobs are populated, so we throw up our hands and
  // tell it to grow() whatever has the lowest money:max_money ratio.
  // We'll probably want to be smarter about this later.
  let job = job_queue.reduce(function (x,y) {
    let xi = info[x.host];
    let yi = info[y.host];
    return xi.money/xi.max_money < yi.money/yi.max_money ? x : y;
  });
  await setJob(worker, job, "grow");
}

// Attempts to estimate how quickly we can extract money from this system, based
// on (target_money * hack_fraction)/hack_time.
// If the system needs to be grown first, we divide this by (1+grows/swarm_size).
// Same deal with weaken.
// This doesn't yet take into account the fact that systems that need to be
// grown will need to be weakened again afterwards.
function getMoneyPerTime(job) {
  let stat = info[job.host];
  return (job.target_money * stat.hack_fraction)
       / (ns.getHackTime(job.host) * (1 + (job.weaken+job.grow)/estimateSwarmSize()));
}

// Sort behaviour.
// If there are machines we can hack right now (i.e. hack=1 and weaken=0), those
// get sorted first, and sorted within themselves by moneyPerTime.
// Everything else is just sorted by moneyPerTime.
function canHack(task) {
  return !task.weaken && task.hack;
}
function sortJobQueue() {
  job_queue.sort(function (x,y) {
    if (canHack(x) != canHack(y)) {
      // If only one of them is hackable, that one has priority.
      return canHack(x) ? -1 : 1;
    }
    // Otherwise prioritize the one with the best payoff per time.
    return getMoneyPerTime(y) - getMoneyPerTime(x);
  });
}

// Guess roughly how many cores are in the swarm based on how many things we
// have working on tasks.
function estimateSwarmSize() {
  return Math.max(
    1, // Avoid divide-by-zero, and if the swarm is empty none of this matters anyways
    job_queue.reduce(function (val, job) {
      return val + job.pending_hack + job.pending_grow + job.pending_weaken;
    }, 0))
}

async function setJob(worker, job, command) {
  log("%18s:  %s  ->  %s %s (×%d)", worker.host,
    (worker.task || ["(idle)"]).join(" "),
    command, job.host, worker.threads);
  job["pending_" + command] += worker.threads;
  worker.job = [command, job.host];
  await rpc.send("SPU@" + worker.host, [command, job.host]);
  // log(" + %s (%s×%d)", jobToString(job), command, worker.threads);
}
