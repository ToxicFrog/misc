// version:2
// SHODAN Processing Unit
// This runs on a machine we have root on (but are not necessarily capable of hacking).
// It is meant to be invoked as: spu.ns hostname threads version
// but in practice you shouldn't run it directly; it should be automatically
// staged and executed by SHODAN.

import * as rpc from "rpc.ns";

var ns;
var HEARTBEAT_CHANNEL = "shodan";
var TASK_CHANNEL;
var TIMEOUT = 60.0;
var hostname; var threads; var version;

function mkHeartbeat(task) {
  return { host:hostname, threads:threads, version:version, task:task };
}

async function recvTask() {
  let task = rpc.recv(TASK_CHANNEL, TIMEOUT);
  if (task) {
    ns.print("Read task '" + task.join(" ") + "' from the controller.");
  } else {
    ns.print("Timed out waiting for task, re-sending heartbeat.");
  }
  return task;
}

async function runTask(task, target) {
  rpc.publishStatus(hostname, mkHeartbeat(task));
  if (task == "hack") return await ns.hack(target);
  if (task == "grow") return await ns.grow(target);
  if (task == "weaken") return await ns.weaken(target);
  if (task == "exit") {
    rpc.publishStatus(hostname, null);
    return ns.exit();
  }
}

export async function main(n) {
  ns = n;
  hostname = ns.args[0] || ns.exit();
  threads = Number(ns.args[1]) || ns.exit();
  version = ns.args[2] || ns.exit();
  TASK_CHANNEL = "SPU@" + hostname;

  ns.disableLog("sleep");

  let task = null;
  while (true) {
    ns.print("Sending heartbeat: " + hostname + " " + threads + " " + version);
    await rpc.send(CONTROL_CHANNEL, mkHeartbeat(task));
    task = await recvTask();
    if (task) {
      ns.print("Executing task: " + task.join(" "));
      await runTask.apply(null, task);
    }
  }
}
