// Libraries for RPC and remote status handling.
// All RPC uses port 20, which is configured to hold a single mutable object
// containing all of the channel contents, as a map from channel name to
// channel content.
// The special channel 0 (the actual number 0, not "0") holds status publications
// and is a map from "script@hostname" to status.
// Users must call rpc.init(ns) before making any calls to other RPC functions.
// Uses 3.60GB, the same as calling peek/write/read directly.

var ns;
var RPC_PORT = 20;
var STATUS_CHANNEL = 0;

function assert(cond, msg) {
  if (!cond) throw msg;
}

export function init(n) {
  ns = n;
  if (ns.peek(RPC_PORT) === "NULL PORT DATA") {
    ns.write(RPC_PORT, {[STATUS_CHANNEL]: {}});
  }
}

// Create a new RPC channel with the specified size (0=unlimited).
// This must be called before any attempt to send or recv on it is made.
// If the channel already exists, it is cleared.
export function create(channel, size=20) {
  ns.peek(RPC_PORT)[channel] = [];
  ns.peek(RPC_PORT)[channel].size = size;
}

// Send a message on the given channel. If the channel is full or missing,
// blocks until it can write the message, or until timeout seconds have
// elapsed; if timeout is set, it retries every 100ms.
// Returns true if the message was sent, false if a timeout occurred.
export async function send(channel, message, timeout=Infinity) {
  while (timeout >= 0) {
    let buf = ns.peek(RPC_PORT)[channel];
    if (buf && buf.length < buf.size) {
      buf.push(message);
      return true;
    }
    await ns.sleep(100);
    timeout -= 0.1;
  }

  return false;
}

// Receive a message from the given channel. If the channel is empty or missing,
// blocks until a message is available or until timeout seconds have elapsed.
// Returns the message, or null if a timeout occurred.
export async function recv(channel, timeout=Infinity) {
  while (timeout >= 0) {
    let buf = ns.peek(RPC_PORT)[channel];
    if (buf && buf.length > 0) return buf.shift();
    await ns.sleep(100);
    timeout -= 0.1;
  }

  return null;
}

// Publish a status update.
// This is written to a special RPC "channel" that is actually a map from
// (program,host) pairs to status.
// The "subkey" is used as a suffix for the name of the script when writing the
// status, so you can e.g. have multiple shards of the same program write
// different subkeys.
// Passing null as the status deletes it from the status table entirely.
export function publishStatus(subkey, status) {
  let key = sprintf("%s%s", ns.getScriptName(), subkey ? "@" + subkey : "");
  if (status === null) {
    delete ns.peek(RPC_PORT)[STATUS_CHANNEL][key];
  } else {
    ns.peek(RPC_PORT)[STATUS_CHANNEL][key] = status;
  }
}

// Read a status update from another program.
// The returned status may be mutable. Please don't mess with it.
// With key=null, returns a map of all statii.
export function readStatus(key) {
  if (key) {
    return ns.peek(RPC_PORT)[STATUS_CHANNEL][key];
  } else {
    return ns.peek(RPC_PORT)[STATUS_CHANNEL];
  }
}
