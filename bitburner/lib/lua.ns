// Library functions for running Lua scripts.

// Runs after libraries and ns are loaded, but before the main program is.
const initializer = String.raw`
-- Set up wrappers around async functions to turn them into coroutine yields.
local function asyncToCoro(f)
  return function(...)
    return coroutine.yield(f(...))
  end
end
for _,name in ipairs { "sleep", "hack", "grow", "weaken", "run", "exec", "prompt", "wget" } do
  ns[name] = asyncToCoro(ns[name])
end

-- Make sleep take fractional seconds rather than millis.
local _sleep = ns.sleep
ns.sleep = function(self, time) return _sleep(self, time*1000) end

-- Set up package searchers.
package.searchers = {
  package.searchers[1]; -- package.preload
  function(name)
    local file = "/lib/" .. name:gsub("%.", "/") .. ".lua.txt"
    if ns:fileExists(file) then
      return load(ns:read(file), "@"..file)
    else
      return "no file '"..file.."';"
    end
  end;
  -- remaining searchers for lua/C files on disk removed
}

-- Error handler. Called when an error is thrown inside lua, just before the
-- script terminates.
-- It'll be called with the erroring thread as the first argument and the error
-- message as the second.
-- User code can replace this, but note that in order for Bitburner error
-- windows to work properly:
-- (1) the original error message should be included at the *front*
-- (2) whatever you append to it should not include the | character
aterror = debug.traceback

-- Override print() to do something useful, and define printf()
function print(...)
  return ns:tprint(table.concat({...}, " "))
end
function printf(fmt, ...)
  return print(fmt:format(...))
end
`

// JS implementation of lua function tomoney(n, [fractional_digits]).
// Returns n in the form "$1,234,567.89".
function L_tomoney(L) {
  const {luaL_checknumber,luaL_optinteger} = fengari.lauxlib;
  const {push} = fengari.interop;
  const n = luaL_checknumber(L, 1);
  const fdigits = luaL_optinteger(L, 2, 0);
  push(L, "$" + n.toLocaleString(undefined, {maximumFractionDigits:fdigits}));
  return 1;
}

export async function luaAvailable(ns) {
  while (typeof(fengari) === "undefined") {
    ns.print("Lua not available yet -- sleeping until it is.");
    await ns.sleep(5*1000);
  }
}

// Create a new lua_State, load libraries, and run the initializer in it.
export function newState(ns) {
  const {to_luastring} = fengari;
  const {lua_setglobal,lua_pushjsfunction} = fengari.lua;
  const {luaL_newstate,luaL_requiref,luaL_dostring} = fengari.lauxlib;
  const {luaL_openlibs} = fengari.lualib;
  const {luaopen_js,push,tojs} = fengari.interop;

  const L = luaL_newstate();
  luaL_openlibs(L);
  luaL_requiref(L, "js", luaopen_js, true);
  push(L, ns);
  lua_setglobal(L, "ns");
  lua_pushjsfunction(L, L_tomoney);
  lua_setglobal(L, "tomoney");

  if (luaL_dostring(L, to_luastring(initializer))) {
    throw Error("Error running initializer: " + tojs(L, -1));
  }

  return L;
}

// Compile buf (a javascript string) and push the result onto the stack
// as a Lua function.
export function loadBuffer(ns, L, buf, name) {
  const {luaL_loadbuffer} = fengari.lauxlib;
  const {tojs} = fengari.interop;

  const luastr = fengari.to_luastring(buf)
  if (!luastr) throw "Error in string conversion loading " + name;
  if (luaL_loadbuffer(L, luastr, luastr.length, name)) {
    throw Error("Error loading " + name + ": " + tojs(L, -1));
  }
}

// Load a file from disk and push it onto the stack as a Lua function.
export function loadFile(ns, L, file) {
  const source = ns.read(file);
  if (!source) {
    throw Error("Error reading source code from " + file);
  }
  return loadBuffer(ns, L, source, "@"+file);
}

// Call the error handler in L, if defined. Returns an error string, which the
// caller is expected to throw.
//
function handleError(L) {
  const {lua_newthread,lua_pop,lua_getglobal,
         lua_xmove,lua_pushthread,lua_pcall,lua_type,
         LUA_TFUNCTION} = fengari.lua;
  const {luaL_typename} = fengari.lauxlib;
  const {tojs} = fengari.interop;

  const E = lua_newthread(L);
  lua_pop(L, 1);

  // Push error handler.
  lua_getglobal(E, "aterror");
  if (lua_type(E, -1) !== LUA_TFUNCTION) {
    // aterror is not defined or is not a function.
    return tojs(L, -1);
  }

  // Push the thread. We have to push it into itself first, then move it over to
  // the error handling thread, since there's no lua_pushotherthread().
  lua_pushthread(L);
  lua_xmove(L, E, 1);

  // Error message is still on top of the stack; move that over too.
  lua_xmove(L, E, 1); // move the error message

  // Try calling it.
  const msg = tojs(E, -1);
  if (lua_pcall(E, 2, 1, 0)) {
    // Something went wrong calling the error handler.
    let newmsg = msg + "<br>Error in Lua error handler: <br>" + tojs(E, -1);
    console.log(newmsg);
    return newmsg;
  }
    console.log("Error handling complete, returning whatever's on top of the stack: "
               + tojs(E, -1));
  return tojs(E, -1);
}

// Call the function on top of the stack in L, passing it args.
// If the function yields something, awaits on it and then resumes it with the
// results of the await.
//
export async function callToCompletion(ns, L, args) {
  const {lua_checkstack,lua_resume,lua_pop,LUA_OK,LUA_YIELD} = fengari.lua;
  const {push,tojs,testjs} = fengari.interop;

  for (const arg of args) {
      push(L, arg);
  }

  let ret = lua_resume(L, null, args.length);
  while (ret != LUA_OK) {
    if (ret == LUA_YIELD) {
      // It gave us a future to wait on!
      let future = tojs(L, -1);
      lua_pop(L, 1);
      let result = await future;
      push(L, result);
      ret = lua_resume(L, null, 1);
    } else {
      // It gave us an error!
      // Before we do anything, we need to allocate some stack space, since both
      // the error handler and testjs() need a free stack slot even if they
      // don't keep using it.
      if (!lua_checkstack(L, 2)) {
        throw "Error initializing the Lua error handler.";
      }

      // If it's a JS object, that probably means it threw the WorkerScript,
      // which means script termination e.g. by kill(1). We can't safely run
      // error handlers or do anything else except re-throw it.
      let thrown = testjs(L, -1);
      if (thrown) throw thrown;

      // Otherwise it's a Lua object that the error handler can at least attempt
      // to make sense of.
      console.log("Error executing script: " + tojs(L, -1));
      const msg = handleError(L).replace(/\n/g, "<br>").replace(/<br>( +)/, "<br><pre>$1</pre>");
      console.log("Error handler returned: " + msg);
      if (msg[0] == "|") {
        throw msg;
      } else {
        throw Error(msg);
      }
    }
  }
}
