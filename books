#!/usr/bin/env zsh
#
# Wrapper around `task` to use it as a book diary management script.
#
# Uses UDFs for author, gender, genre.
# Task description == title, and annotations are used for notes.
#
# Intended usage is:
#   books add author:"C.J. Cherryh" genre:sf gender:f +reread Foreigner
#   ...go off and read it...
#   books 1 done
#   books annote "I really enjoyed this."
#   books bookstats genre
#
### New filters:
# year:XXXX
#   must be the first argument! equivalent to:
#   end.after:XXXX-01-01 end.before:(XXXX+1)-01-01
#
### New commands:
# books reset-config
# books grep <genre, author, or title regex>
# books <filter> bookstats <list of fields>
#   displays counted stats of the different field values, e.g.
#   `books year:2017 genre` shows you what % of books you read in 2017 were
#   what genre.
# books annote <text>
#   annotates the most recently finished book.
#
# TODO:
# - figure out how to normalize the genre tree
# - convert & fields into multiline fields.
# - more feedback on successful actions:
#   - when starting/finishing/logging/adding a book or books, show the modified
#     entries
#   - when finishing a book, if there's another book in the series, show both
#     the book immediately finished and the next book

set -e
source $(dirname $(realpath $0))/tasklib.sh

export TASKRC=$HOME/Books/booklogrc
export YEAR=$(date +%Y)

function main {
  local isfinished="( +COMPLETED and end.after:$YEAR-01-01 and end.before:$((YEAR+1))-01-01 )"
  local isreading="( +ACTIVE and start.before:$((YEAR+1))-01-01 )"
  task/init-config books.defaults \
    "context.$YEAR=$(task/year-filter $YEAR)" \
    "context=$YEAR"
  task/dispatch "$@"
}

task/register new-year '^new-year$' books/new-year <<EOF

  $NAME new-year

Advance the book journal's internal year. It will not advance the current year
automatically on the new year, to make it easy to generate end of year reports
and the like; when you want to advance the year to the current year, use this
command.

(Note that books and annotations are always recorded with the correct date; the
"current year" only affects what books are displayed by default.)
EOF
function books/new-year {
  \task context define $YEAR "$(task/year-filter $YEAR)"
  \task context $YEAR
}

task/register grep '^grep' books/grep <<EOF

  $NAME grep <pattern> [report]

Display books where the author or description match the given pattern (as a
case-insensitive regex) in the given report format; if not specified, the report
defaults to "all". Unlike other commands, searches all years by default.
EOF
function books/grep {
  shift
  \task rc.regex:yes rc.search.case.sensitive:no rc.context: \
    "( author ~ '$1' or desc ~ '$1' )" "${2:=all}"
}

task/register cc '^cc' books/cc <<EOF

  $NAME cc ...

Alias for \`booklord ...\`.
EOF
function books/cc {
  shift
  exec booklord "$@"
}

task/register bookstats 'bookstats' books/bookstats <<EOF

  $NAME [filter] bookstats <field ...>

For all books that match the filter, report:
- the total number of books
- the number of unique authors
- all values of all listed fields, sorted by frequency, along with their counts
  and what % of all books in the filter have that value
Multivalued fields (e.g. books with multiple genres separated by &) will be
counted once for each value, so the total count for a given field may exceed
the number of books matched by the filter.

Note that the filter has an implicit +COMPLETED on it, i.e. only books that are
finished will be counted no matter what the filter is.
EOF
function books/bookstats {
  local FILTER=(+COMPLETED)
  while [[ $1 ]]; do
    if [[ $1 == bookstats ]]; then
      shift; break;
    fi
    FILTER+="$1"
    shift
  done

  # Get number of books and authors to use as a basis for the count.
  # This is somewhat complicated by the fact that _unique does not respect context.
  # So instead we use task/select, which does, and run it through uniq.
  # We also strip off "(tr)" and "(ed)" suffixes, so someone who is credited as
  # both an author and an editor is only counted once.
  local NROF_BOOKS=$(\task "${FILTER[@]}" count)
  local NROF_AUTHORS=$(task/select author author+ "${FILTER[@]}" \
    | sed -E 's, \(ed\),,g; s, \(tr\),,g' | sort | uniq | wc -l)
  printf '\x1B[1m%24s  %-4d (by %d authors)\x1B[0m\n' "BOOKS" "$NROF_BOOKS" "$NROF_AUTHORS"

  # Display prefix only if we have more than one field to collect stats for.
  local FIELD_PREFIX=''
  if (( $# > 1)); then
    FIELD_PREFIX=yes
  fi

  # Get number of occurrences of each value of each field.
  local SPLIT
  for field in "$@"; do
    FIELD_PREFIX="${FIELD_PREFIX:+$field:}"

    if [[ $field == "tags" ]]; then
      FIELD_PREFIX="${FIELD_PREFIX:++}"
      SPLIT=' '
    else
      SPLIT=' & '
    fi

    # FIXME: when processing authors, we should strip out (tr) and (ed) here too.
    task/select "$field" "$field+" "${FILTER[@]}" \
      | sed -E "s,$SPLIT,\n,g" | sed -E 's, +\((tr|ed)\),,g' \
      | sort | uniq -c | sed -E "s,( +[0-9]+ +),\1${FIELD_PREFIX},"
  done | sort -r -g | while read count field; do
    printf '%24s  %-4d (%3.2f%%)\n' "$field" "$count" "$(\task calc "100.0*$count/$NROF_BOOKS")"
  done
}

function task/as-html {
  sed -E 's,$,<br>,'
}

task/register export 'export$' books/export <<EOF

  $NAME [...filters...] export

Export the selected entries in HTML format.
EOF
function books/export {
  shift -p
  printf '
    <style>
      td:empty {
        display: none;
      }
      tr:empty {
        display: none;
      }
    </style>
    <table border=4><tr><th>Finished</th><th>Title</th><th>Author</th></tr>
  '
  task/select uuid end+,entry+ "$@" \
  | task/printf '
    <tr bgcolor="#DDDDDD">
      <td style="width:fit-content;">%end.formatted%s</td>
      <td><b>%description.desc%s</b></td>
      <td style="width:fit-content;">%author%s</td>
    </tr>
    <tr><td colspan=4>%annotations|task/as-html%s</td></tr>
  '
  printf '</table>\n'
}

task/register set-series '^set-series' books/set-series <<EOF

  $NAME set-series <series name> ID [ID...]

Mark the given books as belonging to the named series, in that order.
This doesn't do any sort of series numbering; it just indicates that the first
listed book needs to be read before the second, and that on before the third,
and so forth. Only the next unread book in the series will show up in
'books next'.

Internally, the project: field is used for the series name, and depends: for the
ordering information.
EOF
function books/set-series {
  shift
  local series="$1"; shift
  local prev="$1"; shift
  \task modify "$prev" project:"$series"
  while [[ $1 ]]; do
    \task modify $1 depends:$prev project:"$series"
    prev="$1"
    shift
  done
}

task/register add-series '^add-series' books/add-series <<EOF

  $NAME add-series <series name> <arguments to '$NAME add'> -- <list of book titles>

Add a bunch of books in a series, in the given order. This is equivalent to
calling '$NAME add <args> <title>' on each title, then '$NAME set-series' on
the added books, except you don't need to manually look up the book IDs before
calling set-series.
EOF
function books/add-series {
  shift
  local series="$1"; shift
  local -a add_args=()
  while [[ $1 && $1 != -- ]]; do
    add_args+="$1"; shift
  done
  if [[ $1 != -- ]]; then
    echo >&2 "add-series: missing '--' to separate arguments from titles"
    return 1
  fi
  shift

  if [[ ! $1 ]]; then
    >&2 echo "Missing book titles after -- in add-series; try $NAME help add-series"
    return 1
  fi

  local -a uuids=()
  while [[ $1 ]]; do
    \task add "${add_args[@]}" "$1"; shift
    uuids+=$(\task +LATEST uuids)
  done

  books/set-series _ "$series" "${uuids[@]}"
}

task/register reread ' reread$' books/reread <<EOF

  $NAME [...filters...] reread

Makes copies of the selected books in an unread state and with the "reread" tag
added (if they didn't have it already). Annotations are not copied, but author,
title, genre, etc are.
EOF
function books/reread {
  shift -p
  local rereads=()
  task/select uuid end+ "$@" \
  | task/printf 'author:%author%s\tgenre:%genre%s\tgender:%gender%s\ttags:%.tags%s,reread\t%description.desc%s\n' \
  | while IFS=$'\t' read -A args; do
    main add "${args[@]}"
    rereads+=$(task/select id id+ +LATEST)
  done
  # List the books we just added.
  main "${rereads[@]}" next
}

# books watch => list watched authors
# books watch add $author ... => add an author
# books watch rm $author => remove an author
# books watch update => fetch updates
task/register watch '^watch' books/watch <<EOF

  $NAME watch
  $NAME watch add <author> <author:Name gender:x ...>
  $NAME watch rm <author>
  $NAME watch update

Manipulate the author watchlist. With no arguments, lists all known authors
and when their booklists were last fetched. Add and rm do what it says on the
tin. Update fetches new book releases for each author from Goodreads and
prompts you to add them to the book journal.
EOF
function books/watch {
  local watchdir="$(\task _get rc.data.location | sed -E "s,^~,$HOME,")/bookwatch"
  mkdir -p "$watchdir"
  shift
  if [[ $# == 0 ]]; then
    books/watch-list
    return
  fi

  case "$1" in
    add|list|update|rm)
      local cmd="$1"; shift
      books/watch-$cmd "$@"
      ;;
    *)
      echo "Unknown subcommand: $1"
      return 1
      ;;
  esac
}

function books/watch-list {
  \task _show | egrep '^bookwatch' \
    | sed -E 's,^bookwatch\.,,; s,=, ,;' \
    | while read author config; do
      local last_update=$(stat -c '%y' "$watchdir/$author")
      local nrof_books=$(cat "$watchdir/$author" | wc -l)
      printf '%s %32s  %3d %s\n' "$last_update" "$author" "$nrof_books" "${config//,/ }"
  done
}

function books/watch-add {
  local author="${1/-/_}"; shift
  if [[ $(\task _get "rc.bookwatch.$author") ]]; then
    echo "Already watching an author with id $author"
    return 1
  fi
  \task config -- "bookwatch.$author" "${(@j/,/)@}"
  touch -d "1970-01-01 00:00:00" "$watchdir/$author"
}

function books/watch-rm {
  local author="${1/-/_}"; shift
  if [[ ! $(\task _get "rc.bookwatch.$author") ]]; then
    echo "Not watching an author with id $author"
    return 1
  fi
  \task config -- "bookwatch.$author"
}

function books/-unescape {
  sed -E '
    s,&quot;,",g
    s,&apos;,'\'',g
    s,&#x2014;,—,g
    s,&#x2019;,’,g
    s,&amp;,\&,g
  '
}

# filter-books <file>
# Read <td></td> elements from stdin, and look for ones that have a book title
# already present in <file>. Emit only the ones that do not.
function books/-filter-books {
  local -A seen=()
  cat "$1" | while read -r title; do
    seen[$title]=1
  done
  local -a buf=()
  local exclude=''
  while read -r line; do
    buf+="$line"
    if [[ $line == *'itemprop="name"'* && $line != *authorName* ]]; then
      local title=$(echo "$line" | cut -d'>' -f2 | cut -d'<' -f1 | books/-unescape)
      echo "Checking $title => ${seen[$title]}"
      echo "  [$line]  "
      exclude=${seen[$title]}
    fi
    if [[ $line == *"</td>"* ]]; then
      if ! (( exclude )); then
        printf '%s\n' "${buf[@]}"
      fi
      buf=()
      exclude=''
    fi
  done
}

# watch-update-one <author>
# emits a list of new books by author
function books/-watch-update-one {
  local author="$1"
  # N.b. piping the output of wring into anything causes it to truncate.
  # You need to redirect to a file and then read the file.
  # Ick.
  task/status "%s: fetching book list" "$author"
  cat > "$watchdir/$author.new" <<EOF
# New books for $author
# All books listed here will be added for this author when you close the editor.
# Books you delete or comment out will be remembered as seen (so you won't be
# prompted for them again), but won't be added.
# If you edit a book title, it will be remembered properly but the edited form
# will be added.
EOF
  touch "$watchdir/$author"
  curl -L -s "https://www.goodreads.com/author/list/${author}?utf8=✓&sort=original_publication_year&per_page=1024" \
    | wring h - ".tableList tr td[width='100%']" \
    | books/-filter-books "$watchdir/$author" > "$watchdir/$author.all"
  # So now we have a list of <td> elements, each one containing a book that
  # is not in our seen-list.

  local nrof_books=$(cat "$watchdir/$author.all" | fgrep '</td>' | wc -l)
  for i in {1..$nrof_books}; do
    task/status "%s: %3d/%d" "$author" "$i" "$nrof_books"

    # Get the nth book from the list.
    local td=$(cat "$watchdir/$author.all" | wring h - "//td[$i]")
    # Now we can get the book title:
    local title=$(echo "$td" | wring t - ".bookTitle")
    task/status "%s: %3d/%d | %s" "$author" "$i" "$nrof_books" "$title"
    # And the publication info:
    local pub=$(echo "$td" | wring t - ".smallText")

    if fgrep -qx "$title" "$watchdir/$author"; then
      # We already saw this book in a previous scan.
      # N.b. we can't just bail as soon as we see a book we've seen before,
      # since sometimes books end up without publication dates at all and those
      # always go to the end of the list.
      continue
    fi

    if echo "$pub" | fgrep -q "expected publication"; then
      # Not published yet.
      # Don't record it in the already-seen list or the new list.
      task/status "%s: %3d/%d | [not yet published] %s\\n" \
        "$author" "$i" "$nrof_books" "$title"
      continue
    fi

    if echo "$pub" | fgrep -q "published"; then
      # Book has been published. Add it to both the new list and the seen list.
      task/status "%s: %3d/%d | [new] %s\\n" \
        "$author" "$i" "$nrof_books" "$title"
      echo "$title" >> "$watchdir/$author.new"
      echo "$title" >> "$watchdir/$author"
      continue
    fi

    # TODO: special handling for short stories and anthologies.
    # we can get these from the info page; look for "Anthology" and "Short Story".

    # Couldn't figure out publication info -- query the book's info page.
    task/status "%s: %3d/%d | [loading details] %s" \
      "$author" "$i" "$nrof_books" "$title"
    local url="$(echo "$td" | fgrep 'class="bookTitle"' | egrep -o '/book/show/[^"]+')"
    local bookinfo="$(curl -L -s "https://www.goodreads.com$url" \
      | wring t - '#details, div.left a.bookPageGenreLink')"
    if echo "$bookinfo" | fgrep -q "Expected publication"; then
      task/status "%s: %3d/%d | [not yet published] %s\\n" \
        "$author" "$i" "$nrof_books" "$title"
      continue
    else
      # This covers both "Published" and cases where we can't determine the
      # publication state -- err on the side of caution here.
      task/status "%s: %3d/%d | [new?] %s\\n" \
        "$author" "$i" "$nrof_books" "$title"
      echo "    Error determining publication state: https://www.goodreads.com$url"
      echo "$title" >> "$watchdir/$author.new"
      echo "$title" >> "$watchdir/$author"
    fi
  done

  local nrof_new=$(sed -E '/^#/ d' "$watchdir/$author.new" | wc -l)
  if (( nrof_new > 0 )); then
    nano -R "$watchdir/$author.new"
    sed -E -i '/^#/ d' "$watchdir/$author.new"
    task/status "%s: %d new books, %d to add\\n" \
      "$author" "$nrof_new" "$(cat "$watchdir/$author.new" | wc -l)"
  else
    cat /dev/null > "$watchdir/$author.new"
    task/status "%s: no new books\\n" "$author"
  fi
}

function books/watch-update {
  local -a watched=($(\task _show | egrep '^bookwatch' | sed -E 's,^bookwatch\.,,; s,=.*, ,;'))
  for author in ${watched[@]}; do
    books/-watch-update-one "$author"
    # at this point the seenlist has already been updated
    # and the addlist has been edited by the user
    # so just go through the addlist and add each title
    local config=("$(\task _get rc.bookwatch.$author)")
    cat "$watchdir/$author.new" | while read title; do
      printf "'%s' " books add "${(@s/,/)config}" "$title"
      echo
    done
  done
  return 0
  rm -f "$watchdir/"*.all "$watchdir/"*.new
}

# books/-watch-update-one "5760737.Seth-Dickinson"
# exit $?
exec main "$@"
